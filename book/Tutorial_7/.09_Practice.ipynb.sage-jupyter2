{"backend_state":"init","connection_file":"/tmp/xdg-runtime-user/jupyter/kernel-045fa03c-d77a-42f0-9a73-e74f957cc877.json","kernel":"python3","kernel_error":"","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.8.5"}},"trust":true,"type":"settings"}
{"cell_type":"code","end":1638124597884,"exec_count":1,"id":"3a97b6","input":"import numpy as np\nimport matplotlib.pyplot as plt\n\nz = np.zeros((6,6))\nz[0:3,0:3] = .3\n\n\nfor i in range(5):\n\n    x = np.random.randint(6)\n    y = np.random.randint(6)\n    z[x,y] = 1\n\n\nplt.imshow(z)\n\nimport matplotlib.image as mpimg # import the image module\n\nmpimg.imsave(\"sixbysix.png\", z, vmax = 2, cmap=\"gray\")\n\n","kernel":"python3","output":{"0":{"data":{"image/png":"3f4e00010e1979e7bd87da7db0079396fdbecfdc","text/plain":"<Figure size 864x504 with 1 Axes>"},"metadata":{"image/png":{"height":411,"width":408},"needs_background":"light"}}},"pos":8,"start":1638124597563,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":106,"id":"23569e","input":"import numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.image as mpimg # import the image module\nimport scipy.ndimage as sn # import the scipy.ndimage package\n\nx = mpimg.imread(\"sixbysix.png\") # read the image into an array\nz = np.sum(x, 2) # sum the RGBA values for each pixel\n\nprint(\"Min:\", np.min(z))\nprint(\"Max:\", np.max(z))\n\nthres = 1.4\nx_thres = z > thres # Determine pixels which are above the threshold\nprint(x_thres)\nplt.figure(figsize=(4,4))\nplt.imshow(x_thres) # Note that in Python True = 1 and False = 0\n\nx_labels, n = sn.label(x_thres) # generate \nprint(\"number of blobs:\", n)\nprint(x_labels)\n\nsizes = sn.sum(x_thres, x_labels, range(1, n+1))\nprint(\"sizes:\", sizes)\n\nidx = np.argmax(sizes) # get the index of the largest blob\nprint(\"index:\", idx)\n\nlocation = sn.center_of_mass(x_thres, x_labels, idx + 1) # determine the coordinates of the largest blob\nprint(\"location:\", location)\n\nidx = np.argmax(sizes) # get the index of the largest blob\nprint(\"index:\", idx)\n\nplt.figure(figsize=(4,4))\nplt.imshow(x)\n# arrays are indexed [column, row] whereas scatter plots are ordered [x, y]\n# so we need to reverse the order of the indices\nplt.scatter(location[1], location[0], marker=\"x\", s=300, lw=3)\n\nplt.savefig(\"sixbysix_marked.png\")\n\n\n","output":{"0":{"name":"stdout","output_type":"stream","text":"Min: 1.0\nMax: 2.5058825\n[[ True  True  True False False False]\n [ True  True  True False False False]\n [ True  True  True False False False]\n [ True False False  True False False]\n [False False False False False  True]\n [False  True False False False False]]\nnumber of blobs: 4\n[[1 1 1 0 0 0]\n [1 1 1 0 0 0]\n [1 1 1 0 0 0]\n [1 0 0 2 0 0]\n [0 0 0 0 0 3]\n [0 4 0 0 0 0]]\nsizes: [10.  1.  1.  1.]\nindex: 0\nlocation: (1.2, 0.9)\nindex: 0\n"},"1":{"data":{"image/png":"a1ecafa3d9b461937708001054aa1511bcbdabaf","text/plain":"<Figure size 288x288 with 1 Axes>"},"exec_count":106,"metadata":{"image/png":{"height":248,"width":245},"needs_background":"light"},"output_type":"execute_result"},"2":{"data":{"image/png":"da6ea87b0a7b5253a8c6a69a51e4b2e8178e73a4","text/plain":"<Figure size 288x288 with 1 Axes>"},"exec_count":106,"metadata":{"image/png":{"height":248,"width":245},"needs_background":"light"},"output_type":"execute_result"}},"pos":9,"type":"cell"}
{"cell_type":"code","exec_count":25,"id":"c10b2f","input":"import numpy as np\n\n\nrow1 = np.linspace(0, 4, num=5)\nrow2 = np.linspace(0, 6, num=5)\nrow3 = np.linspace(0, 1, num=5)\n\nq1 = np.zeros((3, 5))\n\nq1[0,:] = row1\nq1[1,:] = row2\nq1[2,:] = row3\n\nprint(a)\n","output":{"0":{"name":"stdout","output_type":"stream","text":"[[0.   1.   2.   3.   4.  ]\n [0.   1.5  3.   4.5  6.  ]\n [0.   0.25 0.5  0.75 1.  ]]\n"}},"pos":2,"type":"cell"}
{"cell_type":"code","exec_count":26,"id":"9259e6","input":"sum_of_rows = np.sum(q1, axis=0)\nsum_of_columns = np.sum(q1, axis=1)\n\nprint(sum_of_rows)\nprint(sum_of_columns)","output":{"0":{"name":"stdout","output_type":"stream","text":"[ 0.    2.75  5.5   8.25 11.  ]\n[10.  15.   2.5]\n"}},"pos":4,"type":"cell"}
{"cell_type":"code","exec_count":28,"id":"b78e13","input":"def threshold(a, x):\n    b = (a >= x)\n    return b\n\nprint(threshold(q1, 1.5))","output":{"0":{"name":"stdout","output_type":"stream","text":"[[False False  True  True  True]\n [False  True  True  True  True]\n [False False False False False]]\n"}},"pos":6,"type":"cell"}
{"cell_type":"markdown","id":"2181f0","input":"## Question 3\nWrite a function `threshold(a, x)` which thresholds the array `a` at the value `x`. The array returned by the function should be the same shape as `a`, and `True` where `a` greater or equal to x, otherwise `False`. Suppose `q1` contains the following data:\n\n$$\\begin{matrix}\n0 & 1 & 2 & 3 & 4 \\\\\n0 & 1.5 & 3 & 4.5 & 6\\\\\n0 & 0.25 & 0.5 & 0.75 & 1\n\\end{matrix}$$\n\n```\nz = threshold(q1, 1.5)\nprint(z)\n[[False False  True  True  True]\n [False  True  True  True  True]\n [False False False False False]]\n```","pos":5,"type":"cell"}
{"cell_type":"markdown","id":"5335e4","input":"## Question 2\n\nUse `np.sum` to create:\n1. A 1 x 3 array containing the sum of the rows\n1. A 1 x 5 array containing the sum of the columns\n\nof the array created in Question 1.","pos":3,"type":"cell"}
{"cell_type":"markdown","id":"765d43","input":"## Question 4\n\nThe image file `sixbysix.png` consists of a large but faint blob in the top left, and a number of small number of bright pixels elsewhere. Follow the particle tracking method in the notes to find and mark the large blob, as below.\n\n1. Read the image into an array and reduce to greyscale\n1. Threshold the array at a suitable value\n1. Find all blobs in the image\n1. Identify the largest blob\n1. Determine the co-ordinates of the largest blob and \n\n![](sixbysix_marked.png)","pos":7,"type":"cell"}
{"cell_type":"markdown","id":"a5da1d","input":"## Question 1\n\nFollow the steps below to create a 3 x 5 numpy array representing the following data:\n$$\\begin{matrix}\n0 & 1 & 2 & 3 & 4 \\\\\n0 & 1.5 & 3 & 4.5 & 6\\\\\n0 & 0.25 & 0.5 & 0.75 & 1\n\\end{matrix}$$\n\n1. Use `np.linspace` or `np.arange` to create three 1 x 5 arrays `[0 1 2 3 4]`, `[0. 1.5 3. 4.5 6.]` and `[0 0.25 0.5 0.75 1.]`.\n1. Use `np.zeros` to create an 5 x 3 array of zeros.\n1. Use slicing to assign each 1 x 5 array to each row of the array.\n","pos":1,"type":"cell"}
{"cell_type":"markdown","id":"a7d5dc","input":"# Practice 9","pos":0,"type":"cell"}
{"id":0,"time":1638543540761,"type":"user"}
{"last_load":1638124264318,"type":"file"}