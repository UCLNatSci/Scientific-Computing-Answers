{"backend_state":"init","connection_file":"/tmp/xdg-runtime-user/jupyter/kernel-c44fd5c3-e082-4a94-92e0-23128d4a6499.json","kernel":"python3","kernel_error":"","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.8.5"}},"trust":true,"type":"settings"}
{"cell_type":"code","exec_count":1,"id":"6f2385","input":"def overlap(x, y):\n    n = min(len(x), len(y))\n    for i in range(n, 0, -1):\n        if x[-i:] == y[:i]:\n            return i\n    return 0\n\nn1 = overlap(\"XXXABC\", \"ABCYYY\")\nn2 = overlap(\"ABCYYY\", \"XXXABC\")\nn3 = overlap(\"XXXABC\", \"ABC\")\nprint(n1, n2, n3)\n\n# [2] find minimum of length of two strings\n# [1] appropriate looping construct\n# [2] if statement with correct string indexing\n# [2] tests pass and function behaves as specified","output":{"0":{"name":"stdout","output_type":"stream","text":"3 0 3\n"}},"pos":2,"type":"cell"}
{"cell_type":"code","exec_count":2,"id":"57d7f9","input":"def merge(x, y):\n    i = overlap(x, y)\n    return x + y[i:]\n\ns1 = merge(\"XXXABC\", \"ABCYYY\")\ns2 = merge(\"ABCYYY\", \"XXXABC\")\ns3 = merge(\"XXXABC\", \"ABC\")\nprint(s1, s2, s3)\n\n# [1] call overlap function\n# [2] calculate merged string \n# [2] tests pass and function behaves as specified ","output":{"0":{"name":"stdout","output_type":"stream","text":"XXXABCYYY ABCYYYXXXABC XXXABC\n"}},"pos":4,"type":"cell"}
{"cell_type":"code","exec_count":3,"id":"25938c","input":"def longest_overlap(sequences):\n    max_overlap = 0\n    max_i = 0\n    max_j = 0\n    for i in range(len(sequences)):\n        for j in range(len(sequences)):\n            if i != j:\n                d = overlap(sequences[i], sequences[j])\n                if d > max_overlap:\n                    max_overlap = d\n                    max_i = i\n                    max_j = j\n    \n    return [max_i, max_j, max_overlap]\n\ni, j, k = longest_overlap([\"XXXABC\", \"ABCYYY\", \"BC\"])\nprint(i, j, k)\n\n# [1] declare max variables\n# [2] two nested for loops\n# [1] test for i=j\n# [1] call overlap function\n# [1] check for maximum\n# [1] update max values\n# [1] return list of values\n# [2] tests pass and function behaves as specified","output":{"0":{"name":"stdout","output_type":"stream","text":"0 1 3\n"}},"pos":6,"type":"cell"}
{"cell_type":"code","exec_count":4,"id":"1605f9","input":"def identify_strand(sequences, n):\n    i, j, d = longest_overlap(sequences)\n    while d >= n:\n        z = merge(sequences[i], sequences[j])\n        del sequences[max(i, j)]\n        del sequences[min(i, j)]\n        sequences.append(z)\n        i, j, d = longest_overlap(sequences)\n    return sequences\n\n# [2] suitable looping construct with correct condition for termination\n# [1] call merge function\n# [3] remove two items in correct order\n# [1] append merged string to list\n# [1] call longest_overlap function\n# [2] tests pass and function behaves as specified\n\nsequences = ['tgaaaattcctttctattttaggccc', 'tgaaaattcctttctattttaggcccatgcaat', 'ggcattagggcggttaa', 'atgcaatggcattagggcggttaa', 'ggttaa', 'tgaaaattcctttctattt', 'taggcccatgcaatggcattagggc']\nidentify_strand(sequences, 4)\n","output":{"0":{"data":{"text/plain":"['tgaaaattcctttctattttaggcccatgcaatggcattagggcggttaa']"},"exec_count":4,"output_type":"execute_result"}},"pos":8,"type":"cell"}
{"cell_type":"code","exec_count":5,"id":"c74a7d","input":"sequence_list = []\nwith open(\"dna_fragments/strand_100.fasta\") as f:\n    for line in f:\n        if line[0] != \">\":\n            sequence_list.append(line.strip())\n            \ns = identify_strand(sequence_list, 4)\nprint(s)","output":{"0":{"name":"stdout","output_type":"stream","text":"['CCCAGGGAGACCACTGACCCATCAACCTGTACGGGAACCTTCTGTATCGTTCTCGGACGGAGAGATAACTACAGTGCCGCTTACAGCCCCTCTGTCGTCG']\n"}},"pos":10,"scrolled":true,"type":"cell"}
{"cell_type":"code","exec_count":6,"id":"0fb1aa","input":"sequence_list = []\nwith open(\"dna_fragments/strand_200.fasta\") as f:\n    for line in f:\n        if line[0] != \">\":\n            sequence_list.append(line.strip())\n            \ns = identify_strand(sequence_list, 4)\nprint(s)\nprint(s[-1]) # longest string is last one in list","output":{"0":{"name":"stdout","output_type":"stream","text":"['GTGTAGGTTCTGACCGATTCGTGC', 'CCGACGTCTGTAATGTAGCCTCATTGTGATTCCACCCTATTGAGGCATTGACTGATGCGGGAAGAGATCTGAAATGAACTGGTCTATGCGACAGAAACTGTGCAGCTACCTAATCTCCTTAGTGTAGGTTCTGACCGATTCGTGCTTCGTTGAGAACTCACAATTTAACAACAGAGGACATAAGCCCTACGCCCATGATC']\nCCGACGTCTGTAATGTAGCCTCATTGTGATTCCACCCTATTGAGGCATTGACTGATGCGGGAAGAGATCTGAAATGAACTGGTCTATGCGACAGAAACTGTGCAGCTACCTAATCTCCTTAGTGTAGGTTCTGACCGATTCGTGCTTCGTTGAGAACTCACAATTTAACAACAGAGGACATAAGCCCTACGCCCATGATC\n"}},"pos":11,"type":"cell"}
{"cell_type":"code","exec_count":7,"id":"f0438c","input":"sequence_list = []\nwith open(\"dna_fragments/strand_500.fasta\") as f:\n    for line in f:\n        if line[0] != \">\":\n            sequence_list.append(line.strip())\n            \ns = identify_strand(sequence_list, 4)\nprint(s[1]) #longest string is last one in list","output":{"0":{"name":"stdout","output_type":"stream","text":"AATCTTTTTCACTGACAGTCATATTGGGGTGCTCCTAAGCTTTTCCACTTGGCTGGGTCTGCTAGGCCTCCGTGCCCGGAGTTTCGGCGCTGTGCTGCCGAGAGCCGGCCATTGTCATTGGGGCCTCACTTGAGGATACCCCGACCTATTTTGTCGGGACCACTCGGGGTAGTCGTTGGGCTTATGCACCGTAAAGTCCTCCGCCGGCCTCCCCGCTACAGAAGATGATAAGCTCCGGCAAGCAATTATGAACAACGCAAGGATCGGCGATATAAACAGAGAAACGGCTGATTACACTTGTTCGTGTGGTATCGCTAAATAGCCTCGCGGAGCCTTATGCCATACTCGTCCGCGGAGCACTCTGGTAACGCTTATGGTCCATAGGACATTCATCGCTTCCGGGTATGCGCTCTATTTGACGATCCTTTGGCGCACAGATGCTGGCCACGAGCTAAATTAGAGCGACTGCACAACTGTAAGGTCCGTCACGCAGACGACGG\n"}},"pos":12,"type":"cell"}
{"cell_type":"code","exec_count":8,"id":"c097c1","input":"# [1] correctly open file\n# [1] loop over lines\n# [2] form list of strands ommiting lines starting '>'\n# [1] call identify_strand\n# [1] identify longest one (OK to do this by eye but must be commented or otherwise identified)\n# [2] repeat for the other two files (could be loop or repeated code)","pos":13,"type":"cell"}
{"cell_type":"markdown","id":"217c73","input":"# NSCI0007 Practice Exam 1\n## Specimen Answers and Mark Scheme\n- The specimen code below demonstrates one way to correctly answer the questions.\n- Full marks will be awarded if the candidate has implemented another suitable method and the code behaves as specified in the question.\n- If the candidate's code produces an error, or does not behave as specified in the question, partial credit will be awarded as described in the mark scheme.\n- Where a candidate has used a different method to below, partial credit will be awarded in an analogous way.","pos":0,"type":"cell"}
{"cell_type":"markdown","id":"22aaab","input":"## Question 4 [10]","pos":7,"type":"cell"}
{"cell_type":"markdown","id":"ca0d35","input":"## Question 3 [10]","pos":5,"type":"cell"}
{"cell_type":"markdown","id":"e45f9c","input":"## Question 2 [5]","pos":3,"type":"cell"}
{"cell_type":"markdown","id":"e92b9b","input":"## Question 1 [7]","pos":1,"type":"cell"}
{"cell_type":"markdown","id":"f67ab0","input":"## Question 5 [8]","pos":9,"type":"cell"}
{"id":0,"time":1638974053279,"type":"user"}
{"last_load":1638974053249,"type":"file"}