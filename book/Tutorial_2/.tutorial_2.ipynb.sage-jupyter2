{"backend_state":"init","connection_file":"/tmp/xdg-runtime-user/jupyter/kernel-8fb894fe-057d-45f8-8208-65349beafcb8.json","kernel":"python3","kernel_error":"","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.8.10"}},"trust":true,"type":"settings"}
{"cell_type":"code","exec_count":0,"id":"cab1a0","input":"","pos":12,"type":"cell"}
{"cell_type":"code","exec_count":1,"id":"b600b1","input":"# this question is perhaps harder than it intially looks.\n# The key is to take it break it down into individual steps before\n# starting  to write any code.\n\ndef print_square(n):\n    for i in range(n):\n        print(\"*\", end=\"\")\n    print()\n    for i in range(n - 2):\n        print(\"*\", end = \"\")\n        for j in range(n - 2):\n            print(\" \", end=\"\")\n        print(\"*\")\n    for i in range(n):\n        print(\"*\", end=\"\")\n    print()\n        \ndef print_rhombus(n):\n    for i in range(n-1):\n        print(\" \", end=\"\")\n    for i in range(n):\n        print(\"*\", end=\"\")\n    print()\n    for i in range(n - 2):\n        for j in range(n - 2 - i):\n            print(\" \", end=\"\")\n        print(\"*\", end=\"\")\n        for j in range(n-2):\n            print(\" \", end=\"\")\n        print(\"*\")\n    for i in range(n):\n        print(\"*\", end=\"\")\n    print()\nprint_square(5)\nprint()\nprint_rhombus(5)","output":{"0":{"name":"stdout","output_type":"stream","text":"*****\n*   *\n*   *\n*   *\n*****\n\n    *****\n   *   *\n  *   *\n *   *\n*****\n"}},"pos":1,"type":"cell"}
{"cell_type":"code","exec_count":2,"id":"0b21a3","input":"# It is crucial to understand the importance of the return statement.\n# The return statement determines the *output* of the function.\n# For 1 and 2 the function shoud return a value of True or False.\n\n# 1. The expression n % m == 0 is True if n is divisible m; otherwise false\ndef is_divisible(n, m):\n    return n % m == 0\n\n# 2. Construct a loop and *immediately* exit the function as soon as\n# a value which divides into n. Only if no such value is found will the final return statement be reached.\ndef is_prime(n):\n    for m in range(2, n):\n        if is_divisible(n, m):\n            return False\n    return True\n\ndef number_of_primes(n):\n    i = 0\n    for m in range(2, n+1):\n        if is_prime(m):\n            i += 1\n    return i\n            \nprint(\"4 is divisible by 2:\", is_divisible(4, 2))\nprint(\"4 is divisible by 3:\", is_divisible(4, 3))\n\nprint(\"7 is a prime number:\", is_prime(7))\nprint(\"8 is a prime number:\", is_prime(8))\n\nprint(\"Number of prime numbers up to 10:\", number_of_primes(10))\nprint(\"Number of prime numbers up to 11:\", number_of_primes(11))\n    \n    ","output":{"0":{"name":"stdout","output_type":"stream","text":"4 is divisible by 2: True\n4 is divisible by 3: False\n7 is a prime number: True\n8 is a prime number: False\nNumber of prime numbers up to 10: 4\nNumber of prime numbers up to 11: 5\n"}},"pos":3,"type":"cell"}
{"cell_type":"code","exec_count":3,"id":"fe4127","input":"# 1. \n\ndef vol_disc(R, x, dx):\n    r = (R**2 - x**2)**0.5\n    return 3.14159 * r ** 2 * dx\n    # We hardcode the value of pi here. Later you will learn about numpy, a mathematical\n    # library containing many useful functions, including a value for pi.\n\n","pos":5,"scrolled":true,"type":"cell"}
{"cell_type":"code","exec_count":4,"id":"c3eb13","input":"# 2. We first set variables containing values we will use in the computation.\nvol = 0\nd = 2 / 10 # width of each disc\nfor i in range(10):\n    x = -1 + (i / 10) * 2 # the x position of the left-hand edge of each disc\n    vol += vol_disc(1, x, d)\n    \nprint(\"Volume of sphere radius 1:\", vol)\n\n# let's check it against the formula vol = (4/3)*pi*r**3\nprint(\"4/3 * pi * 1^3:\", (4/3) * 3.14159)","output":{"0":{"name":"stdout","output_type":"stream","text":"Volume of sphere radius 1: 4.1468988\n4/3 * pi * 1^3: 4.188786666666666\n"}},"pos":7,"type":"cell"}
{"cell_type":"code","exec_count":5,"id":"d81896","input":"def sphere_vol(R, n):\n    vol = 0\n    dx = 2 * R / n\n    pi = 3.14159\n    for i in range(n):\n        x = -R + (i / n) * 2 * R # x is the position of the  left-hand edge of each disc\n        vol += vol_disc(R, x, dx)\n    return vol\n","pos":9,"type":"cell"}
{"cell_type":"code","exec_count":9,"id":"78d9eb","input":"diff = 1\nvol = 0\nn = 2\nwhile diff > 1e-4 or diff < -1e-4:\n    vol_prev = vol\n    vol = sphere_vol(1, n)\n    diff = vol - vol_prev\n    print(vol)\n\n    n += 1\n    # print(\"vol:\", vol)\n    # print(\"diff:\", diff)\n        \nprint(\"n =\", n, \"vol =\", vol)","output":{"0":{"name":"stdout","output_type":"stream","text":"3.14159\n3.7233659259259255\n3.9269874999999996\n4.0212352\n4.07243148148148\n4.103301224489796\n4.123336875\n4.137073251028807\n4.1468988\n4.154168595041322\n4.159697870370369\n4.164000946745562\n4.167415306122448\n4.170169837037037\n4.17242421875\n4.174292595155709\n4.175858312757201\n4.177183379501384\n4.1783147000000005\n4.17928828420257\n4.18013214876033\n4.180868355387524\n4.181514467592592\n4.182084608\n4.182590236686392\n4.183040731595793\n4.183443826530612\n4.1838059453032095\n4.184132459259258\n4.1844278876170655\n4.1846960546875\n4.18494021426385\n4.185163148788927\n4.185367248979591\n4.185554578189301\n4.1857269247626006\n4.1858858448753455\n4.186032697786543\n4.186168674999999\n4.186294824509221\n4.1864120710506425\n4.186521233098971\n4.186623037190083\n4.186718130041153\nn = 46 vol = 4.186718130041153\n"}},"pos":11,"type":"cell"}
{"cell_type":"markdown","id":"2d2744","input":"4. This is another application of a `while` loop. We need to terminate once the difference between consecutive estimates is less than the tolerance of $1 \\times 10^{-4}$.\n\nTo calculate this, we need to keep track of the previous estimate using a variable `vol_prev` then calculate the difference. But note that the difference could be positive or negative, which is why we have the condition `diff > 1e-4 and diff < -1e-4`. When we learn about `numpy` we can instead use the function `np.abs`.","pos":10,"type":"cell"}
{"cell_type":"markdown","id":"345698","input":"# Tutorial 2\n\n## Question 1","pos":0,"type":"cell"}
{"cell_type":"markdown","id":"7076c7","input":"2. Next, calculate the sum of 10 discs. The width of each is 2 / 10.\n\nThere are 10 discs, with `i` running from `0` to `9`. Left hand edge of disc `i` is at position `x=-1 + (i/10) * 2`.","pos":6,"type":"cell"}
{"cell_type":"markdown","id":"b74dd4","input":"## Question 3\n\nThis question is designed to allow you to combine loops and functions together.\nIt is a very typical example of how we might perform a computation in scientific computing.\nIf you couldn't complete it this time it would make excellent exam preparation!\n\nWe need to calculate the sum of the areas of the discs in the following diagram.\n\n\n```{image} sphere_vol.jpg\n:alt: sphere volume\n:width: 500px\n```\n\n1. First, write a function `vol_disc` which returns the volume of a single disc. Writing the function first allows to test this code separately from the remaining complexity of the problem. ","pos":4,"type":"cell"}
{"cell_type":"markdown","id":"edb716","input":"## Question 2","pos":2,"type":"cell"}
{"cell_type":"markdown","id":"f37eca","input":"3. Extend to a sphere of radius `R` divided into `n` discs. Left hand edge of disc `i` is at position `x = -R + (i / n) * 2 * R`.","pos":8,"type":"cell"}
{"id":0,"time":1636717379274,"type":"user"}
{"last_load":1636717378565,"type":"file"}