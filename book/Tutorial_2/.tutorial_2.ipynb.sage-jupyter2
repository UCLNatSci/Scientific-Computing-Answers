{"backend_state":"running","connection_file":"/tmp/xdg-runtime-user/jupyter/kernel-92ea355f-a4c7-4300-af58-8090abca4446.json","kernel":"python3","kernel_error":"","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.8.10"}},"trust":true,"type":"settings"}
{"cell_type":"code","exec_count":1,"id":"0b21a3","input":"# It is crucial to understand how the importance of the return statement.\n# The return statement determines the *output* of the function.\n# For 1 and 2 the function shoud return a value of True or False.\n\n# 1. The expression n % m == 0 is True if n is divisible m; otherwise false\ndef is_divisible(n, m):\n    return n % m == 0\n\n# 2. Construct a loop and *immediately* exit the function as soon as\n# a value which divides into n. Only if no such value is found will the final return statement be reached.\ndef is_prime(n):\n    for m in range(2, n):\n        if is_divisible(n, m):\n            return False\n    return True\n\ndef number_of_primes(n):\n    i = 0\n    for m in range(2, n+1):\n        if is_prime(m):\n            i += 1\n    return i\n            \nprint(\"4 is divisible by 2:\", is_divisible(4, 2))\nprint(\"4 is divisible by 3:\", is_divisible(4, 3))\n\nprint(\"7 is a prime number:\", is_prime(7))\nprint(\"8 is a prime number:\", is_prime(8))\n\nprint(\"Number of prime numbers up to 10:\", number_of_primes(10))\nprint(\"Number of prime numbers up to 11:\", number_of_primes(11))\n    \n    ","output":{"0":{"name":"stdout","output_type":"stream","text":"4 is divisible by 2: True\n4 is divisible by 3: False\n7 is a prime number: True\n8 is a prime number: False\nNumber of prime numbers up to 10: 4\nNumber of prime numbers up to 11: 5\n"}},"pos":3,"type":"cell"}
{"cell_type":"code","exec_count":1,"id":"fe4127","input":"# This question is designed to allow you to combine loops and functions together.\n# It is a very typical example of how we might perform a computation in scientific computing.\n# If you couldn't complete it this time it would make excellent exam preparation!\n\n# 1. Writing the function first allows to test this code separately from the remaining complexity\n# of the problem. \n\ndef vol_disc(R, x, dx):\n    r = (R**2 - x**2)**0.5\n    return 3.14159 * r ** 2 * dx\n    # We hardcode the value of pi here. Later you will learn about numpy, a mathematical\n    # library containing many useful functions, including a value for pi.\n\n# 2. We first set variables containing values we will use in the computation.\nvol = 0\ndx = 2 / 10 # width of each disc\nfor i in range(10):\n    x = -1 + (i / 10) * 2 # the x position of the left-hand edge of each disc\n    vol += vol_disc(1, x, dx)\n    \nprint(\"Volume of sphere radius 1:\", vol)\n\n# let's check it against the formula vol = (4/3)*pi*r**3\nprint(\"4/3 * pi * 1^3:\", (4/3) * 3.14159)\n\n# 3. It would be a good idea to draw a diagram before writing this code. \n\ndef sphere_vol(R, n):\n    vol = 0\n    dx = 2 * R / n\n    pi = 3.14159\n    for i in range(n):\n        x = -R + (i / n) * 2 * R # x is the position of the  left-hand edge of each disc\n        vol += vol_disc(R, x, dx)\n    return vol\n\n# 4. Use a while loop so that we terminate once we reach the required level of accuracy\n        \ndiff = 1\nvol = 0\nn = 2\nwhile diff > 1e-4:\n    vol_prev = vol\n    vol = sphere_vol(1, n)\n    diff = vol - vol_prev\n    # could use np.abs here instead (when you learn about numpy)\n    if diff < 0:\n        diff = diff * -1\n    n += 1\n    # print(\"vol:\", vol)\n    # print(\"diff:\", diff)\n        \nprint(n)\nprint(vol)\n    ","kernel":"python3","output":{"0":{"name":"stdout","text":"Volume of sphere radius 1: 4.1468988\n4/3 * pi * 1^3: 4.188786666666666\n46\n4.186718130041153\n"}},"pos":5,"scrolled":true,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":16,"id":"b600b1","input":"# this question is perhaps harder than it intially looks.\n# The key is to take it break it down into individual steps before\n# starting  to write any code.\n\ndef print_square(n):\n    for i in range(n):\n        print(\"*\", end=\"\")\n    print()\n    for i in range(n - 2):\n        print(\"*\", end = \"\")\n        for j in range(n - 2):\n            print(\" \", end=\"\")\n        print(\"*\")\n    for i in range(n):\n        print(\"*\", end=\"\")\n    print()\n        \ndef print_rhombus(n):\n    for i in range(n-1):\n        print(\" \", end=\"\")\n    for i in range(n):\n        print(\"*\", end=\"\")\n    print()\n    for i in range(n - 2):\n        for j in range(n - 2 - i):\n            print(\" \", end=\"\")\n        print(\"*\", end=\"\")\n        for j in range(n-2):\n            print(\" \", end=\"\")\n        print(\"*\")\n    for i in range(n):\n        print(\"*\", end=\"\")\n    print()\nprint_square(5)\nprint()\nprint_rhombus(5)","output":{"0":{"name":"stdout","output_type":"stream","text":"*****\n*   *\n*   *\n*   *\n*****\n\n    *****\n   *   *\n  *   *\n *   *\n*****\n"}},"pos":1,"type":"cell"}
{"cell_type":"markdown","id":"118d53","input":"# Tutorial 2\n\n## Question 1\n\nUse `for` loops and `print(end=\"\")` to write functions which print the following patterns:\n\n1. `print_square(n)` where `n` is the number of stars along each edge.\n\n```\n*****\n*   *\n*   *\n*   *\n*****\n```\n2. `print_rhombus(n)` where `n` is the number of stars along each edge.\n\n```\n    *****\n   *   *\n  *   *\n *   *\n*****\n```\n \n3. `print_numbers(n)` where `n` is the number at the centre.\n\n```\n1       1\n 2     2\n  3   3\n   4 4\n    5\n   4 4\n  3   3\n 2     2\n1       1\n```","pos":0,"type":"cell"}
{"cell_type":"markdown","id":"e0b9a7","input":"## Question 3\n\nA [solid of revolution](https://en.wikipedia.org/wiki/Solid_of_revolution) is a three-dimensional figure contstructed by rotating a curve about a straight line. We can estimate the volume of a solid of revolution by dividing it into a sequence of stacked discs and summing the volume of each.\n\nA sphere of radius $R$ is formed by rotating the curve $y = \\sqrt{R^2 - x^2}$ around the x-axis between $-R$ and $R$.\n\n![a](https://miro.medium.com/max/2400/0*d7QEcno6XhPOiJSt.png)\n\nUse the following steps to estimate the volume of a sphere of radius 1.\n\n1. Write a function `vol_disc(R, x, dx)` which returns the volume of the disc centred at position `x` with thickness `dx`. \n1. Estimate the volume of a sphere of radius 1 by dividing the figure into 10 discs equally spaced between `-1` and `1` [use a value of 3.14159 for $\\pi$].\n1. Write a function `sphere_vol(R, n)` which returns the estimate of the volume of a sphere of radius `R` calculated by dividing it into `n` discs.\n1. The estimate should get more accurate as we increase `n`. We can estimate the accuracy by calculating the difference between `sphere_vol(R, n)` and `sphere_vol(R, n-1)`. For `R = 1`, how large does `n` need to be so that difference between consecutive estimates is less than $10^{-4}$?","pos":4,"type":"cell"}
{"cell_type":"markdown","id":"edb716","input":"## Question 2\n\nAn integer $n$ is a *prime number* if it is divisible only by 1 and $n$. \n\n1. Write a function `is_divisible(n, m)` which returns `True` if `n` is divisible by `m`, and otherwise returns `False`.\n1. Write a function `is_prime(n)` which returns `False` if `n` is divisible by any integer between `2` and `n-1`, and otherwise returns `True`.\n1. Write a function `number_of_primes(n)` which returns the number of prime numbers less than or equal to `n` [NB 1 is *not* a prime number].\n\nCheck the correctness of your functions by writing two tests for each.","pos":2,"type":"cell"}
{"id":0,"time":1636111074636,"type":"user"}
{"last_load":1635793093722,"type":"file"}